// powerbi.extensibility.utils.type
import { pixelConverter as PixelConverter } from "powerbi-visuals-utils-typeutils";
// powerbi.extensibility.utils.formatting
import * as formatting from "powerbi-visuals-utils-formattingutils";
var DisplayUnitSystemType = formatting.displayUnitSystemType.DisplayUnitSystemType;
var font = formatting.font;
var numberFormat = formatting.formattingService.numberFormat;
var formattingService = formatting.formattingService.formattingService;
var textMeasurementService = formatting.textMeasurementService;
var valueFormatter = formatting.valueFormatter;
// powerbi.extensibility.utils.svg
import * as svg from "powerbi-visuals-utils-svgutils";
var createClassAndSelector = svg.CssConstants.createClassAndSelector;
import { PointLabelPosition } from "./dataLabelInterfaces";
import DataLabelManager from "./dataLabelManager";
export const maxLabelWidth = 50;
export const defaultLabelDensity = "50";
export const DefaultDy = "-0.15em";
export const DefaultFontSizeInPt = 9;
export const StandardFontFamily = font.Family.regular.css;
export const LabelTextProperties = {
    fontFamily: font.Family.regularSecondary.css,
    fontSize: PixelConverter.fromPoint(DefaultFontSizeInPt),
    fontWeight: "normal",
};
export const defaultLabelColor = "#777777";
export const defaultInsideLabelColor = "#ffffff";
export const hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
export const defaultLabelPrecision = undefined;
const defaultCountLabelPrecision = 0;
const labelGraphicsContextClass = createClassAndSelector("labels");
const linesGraphicsContextClass = createClassAndSelector("lines");
const labelsClass = createClassAndSelector("data-labels");
const lineClass = createClassAndSelector("line-label");
const DimmedOpacity = 0.4;
const DefaultOpacity = 1.0;
function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
    if ((hasPartialHighlights && !highlight) || (hasSelection && !selected)) {
        return DimmedOpacity;
    }
    return DefaultOpacity;
}
export function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
    if (!labelsObj) {
        return;
    }
    if (labelsObj.show !== undefined) {
        labelSettings.show = labelsObj.show;
    }
    if (labelsObj.showSeries !== undefined) {
        labelSettings.show = labelsObj.showSeries;
    }
    if (labelsObj.color !== undefined) {
        labelSettings.labelColor = labelsObj.color.solid.color;
    }
    if (labelsObj.labelDisplayUnits !== undefined) {
        labelSettings.displayUnits = labelsObj.labelDisplayUnits;
    }
    if (labelsObj.labelPrecision !== undefined) {
        labelSettings.precision = (labelsObj.labelPrecision >= 0)
            ? labelsObj.labelPrecision
            : defaultLabelPrecision;
    }
    if (labelsObj.fontSize !== undefined) {
        labelSettings.fontSize = labelsObj.fontSize;
    }
    if (labelsObj.showAll !== undefined) {
        labelSettings.showLabelPerSeries = labelsObj.showAll;
    }
    if (labelsObj.labelStyle !== undefined) {
        labelSettings.labelStyle = labelsObj.labelStyle;
    }
    if (labelsObj.labelPosition) {
        labelSettings.position = labelsObj.labelPosition;
    }
}
export function getDefaultLabelSettings(show = false, labelColor, fontSize) {
    return {
        show: show,
        position: PointLabelPosition.Above,
        displayUnits: 0,
        precision: defaultLabelPrecision,
        labelColor: labelColor || defaultLabelColor,
        fontSize: fontSize || DefaultFontSizeInPt,
    };
}
/* eslint-disable-next-line @typescript-eslint/no-unused-vars */
export function getDefaultColumnLabelSettings(isLabelPositionInside) {
    const labelSettings = getDefaultLabelSettings(false, undefined);
    labelSettings.position = null;
    labelSettings.labelColor = undefined;
    return labelSettings;
}
export function getDefaultPointLabelSettings() {
    return {
        show: false,
        position: PointLabelPosition.Above,
        displayUnits: 0,
        precision: defaultLabelPrecision,
        labelColor: defaultLabelColor,
        fontSize: DefaultFontSizeInPt,
    };
}
export function getLabelPrecision(precision, format) {
    if (precision !== defaultLabelPrecision) {
        return precision;
    }
    if (format === "g" || format === "G") {
        return;
    }
    if (format) {
        // Calculate precision from positive format by default
        const positiveFormat = numberFormat.getComponents(format).positive, formatMetadata = numberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
        if (formatMetadata.hasDots) {
            return formatMetadata.precision;
        }
    }
    // For count fields we do not want a precision by default
    return defaultCountLabelPrecision;
}
export function drawDefaultLabelsForDataPointChart({ data, context, layout, viewport, isAnimator, animationDuration, hasSelection, hideCollidedLabels = true }) {
    // Hide and reposition labels that overlap
    const dataLabelManager = new DataLabelManager();
    const filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, false, hideCollidedLabels);
    const hasAnimation = isAnimator && !!animationDuration;
    const selectedLabels = selectLabels({ filteredData, context, hasAnimation, animationDuration });
    if (!selectedLabels) {
        return;
    }
    // Draw default labels
    selectedLabels
        .text((d) => d.labeltext)
        .attr("x", (d) => d.labelX)
        .attr("y", (d) => d.labelY);
    if (hasAnimation) {
        // Add opacity animation
        selectedLabels
            .transition("")
            .duration(animationDuration)
            .style("opacity", hasSelection ? (d => getFillOpacity(d.selected, false, hasSelection, false))() : 1);
    }
    else {
        // Set opacity to default
        selectedLabels
            .style(layout.style.toString());
    }
    if (layout === null || layout === void 0 ? void 0 : layout.style) {
        Object.keys(layout.style).forEach(style => selectedLabels.style(style, layout.style[style]));
    }
    return selectedLabels;
}
function selectLabels({ filteredData, context, isDonut, hasAnimation, animationDuration }) {
    // Guard for a case where resizing leaves no labels - then we need to remove the labels "g"
    if (!filteredData.length) {
        cleanDataLabels(context, true);
        return null;
    }
    if (context.select(labelGraphicsContextClass.selectorName).empty()) {
        context.append("g").classed(labelGraphicsContextClass.className, true);
    }
    // line chart ViewModel has a special "key" property for point identification since the "identity" field is set to the series identity
    const hasKey = filteredData[0].key != null;
    const hasDataPointIdentity = filteredData[0].identity != null;
    let getIdentifier;
    switch (true) {
        case hasKey:
            getIdentifier = (d) => d.key;
            break;
        case hasDataPointIdentity:
            getIdentifier = d => d.identity.getKey();
            break;
        case isDonut:
            getIdentifier = d => d.data.identity.getKey();
            break;
    }
    const labels = context
        .select(labelGraphicsContextClass.selectorName)
        .selectAll(labelsClass.selectorName)
        .data(filteredData, getIdentifier);
    if (hasAnimation) {
        labels
            .exit()
            .transition()
            .duration(animationDuration)
            .style("opacity", 0) // fade out labels that are removed
            .remove();
    }
    else {
        labels.exit().remove();
    }
    const allLabels = labels.enter()
        .append("text")
        .classed(labelsClass.className, true)
        .merge(labels);
    if (hasAnimation) {
        allLabels.style("opacity", 0);
    }
    return allLabels;
}
export function cleanDataLabels(context, removeLines = false) {
    const emptyData = [];
    const labels = context.selectAll(labelsClass.selectorName).data(emptyData);
    labels
        .exit()
        .remove();
    context
        .selectAll(labelGraphicsContextClass.selectorName)
        .remove();
    if (removeLines) {
        const lines = context
            .selectAll(lineClass.selectorName)
            .data(emptyData);
        lines
            .exit()
            .remove();
        context
            .selectAll(linesGraphicsContextClass.selectorName)
            .remove();
    }
}
export function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
    context
        .selectAll(labelsClass.selectorName)
        .style("fill-opacity", (d) => {
        const fillOpacity = getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
        const labelOpacity = fillOpacity < 1 ? 0 : 1;
        return labelOpacity;
    });
}
export function getLabelFormattedText(options) {
    var _a, _b;
    const properties = {
        text: ((_a = options.formatter) === null || _a === void 0 ? void 0 : _a.format(options.label)) || formattingService.formatValue(options.label, options.format),
        fontFamily: LabelTextProperties.fontFamily,
        fontSize: PixelConverter.fromPoint(options.fontSize),
        fontWeight: LabelTextProperties.fontWeight,
    };
    return textMeasurementService.getTailoredTextOrDefault(properties, (_b = options.maxWidth) !== null && _b !== void 0 ? _b : maxLabelWidth);
}
export function enumerateDataLabels(options) {
    if (!options.dataLabelsSettings) {
        return;
    }
    const instance = {
        objectName: "labels",
        selector: options.selector,
        properties: {},
    };
    if (options.show && options.selector) {
        instance.properties["showSeries"] = options.dataLabelsSettings.show;
    }
    else if (options.show) {
        instance.properties["show"] = options.dataLabelsSettings.show;
    }
    instance.properties["color"] = options.dataLabelsSettings.labelColor || defaultLabelColor;
    if (options.displayUnits) {
        instance.properties["labelDisplayUnits"] = options.dataLabelsSettings.displayUnits;
    }
    if (options.precision) {
        const precision = options.dataLabelsSettings.precision;
        instance.properties["labelPrecision"] = precision === defaultLabelPrecision ? null : precision;
    }
    if (options.position) {
        instance.properties["labelPosition"] = options.dataLabelsSettings.position;
        if (options.positionObject) {
            instance.validValues = { "labelPosition": options.positionObject };
        }
    }
    if (options.labelStyle) {
        instance.properties["labelStyle"] = options.dataLabelsSettings.labelStyle;
    }
    if (options.fontSize) {
        instance.properties["fontSize"] = options.dataLabelsSettings.fontSize;
    }
    if (options.labelDensity) {
        const lineChartSettings = options.dataLabelsSettings;
        if (lineChartSettings) {
            instance.properties["labelDensity"] = lineChartSettings.labelDensity;
        }
    }
    // Keep show all as the last property of the instance.
    if (options.showAll) {
        instance.properties["showAll"] = options.dataLabelsSettings.showLabelPerSeries;
    }
    options.instances.push(instance);
    return instance;
}
export function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory = false, fontSize) {
    const labelSettings = (dataLabelsSettings)
        ? dataLabelsSettings
        : getDefaultPointLabelSettings();
    const instance = {
        objectName: "categoryLabels",
        selector: null,
        properties: {
            show: isShowCategory
                ? labelSettings.showCategory
                : labelSettings.show,
            fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : DefaultFontSizeInPt,
        },
    };
    if (withFill) {
        instance.properties["color"] = labelSettings.categoryLabelColor
            ? labelSettings.categoryLabelColor
            : labelSettings.labelColor;
    }
    if (fontSize) {
        instance.properties["fontSize"] = fontSize;
    }
    enumeration.instances.push(instance);
}
export function createColumnFormatterCacheManager() {
    return {
        cache: { defaultFormatter: null },
        getOrCreate(formatString, labelSetting, value2) {
            if (formatString) {
                const cacheKeyObject = {
                    formatString: formatString,
                    displayUnits: labelSetting.displayUnits,
                    precision: getLabelPrecision(labelSetting.precision, formatString),
                    value2: value2
                };
                const cacheKey = JSON.stringify(cacheKeyObject);
                if (!this.cache[cacheKey]) {
                    this.cache[cacheKey] = valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                }
                return this.cache[cacheKey];
            }
            if (!this.cache.defaultFormatter) {
                this.cache.defaultFormatter = valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
            }
            return this.cache.defaultFormatter;
        }
    };
}
export function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
    return {
        displayUnitSystemType: DisplayUnitSystemType.DataLabels,
        format: formatString,
        precision: precision,
        value: labelSetting.displayUnits,
        value2: value2,
        allowFormatBeautification: true,
    };
}
export function isTextWidthOverflows(textWidth, maxTextWidth) {
    return textWidth > maxTextWidth;
}
export function isTextHeightOverflows(textHeight, innerChordLength) {
    return textHeight > innerChordLength;
}
//# sourceMappingURL=dataLabelUtils.js.map