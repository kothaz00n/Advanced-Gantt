import powerbi from "powerbi-visuals-api";
import { IRect } from "powerbi-visuals-utils-svgutils";
import { IDataLabelSettings, IDataLabelInfo, LabelEnabledDataPoint, ILabelLayout, DataPointLabels } from "./dataLabelInterfaces";
/**
* Arranges label elements using the anchor point or rectangle. Collisions
* between elements can be automatically detected and as a result elements
* can be repositioned or get hidden.
*/
export default class DataLabelManager {
    static DefaultAnchorMargin: number;
    static DefaultMaximumMovingDistance: number;
    static DefaultMinimumMovingDistance: number;
    static InflateAmount: number;
    movingStep: number;
    hideOverlapped: boolean;
    private defaultDataLabelSettings;
    get defaultSettings(): IDataLabelSettings;
    /** Arranges the labels position and visibility */
    /**
     * Hides collided labels within the given viewport.
     *
     * @template T - The type of data points.
     * @param {powerbi.IViewport} viewport - The viewport dimensions.
     * @param {T[]} data - The array of data points to process.
     * @param {ILabelLayout} layout - The layout configuration for labels.
     * @param {boolean} [addTransform=false] - Whether to add a transform to the label positions.
     * @param {boolean} [hideCollidedLabels=true] - Whether to hide labels that collide with others.
     * @returns {(T & LabelEnabledDataPoint)[]} - The array of data points with non-colliding labels.
     */
    hideCollidedLabels<T extends DataPointLabels>(viewport: powerbi.IViewport, data: T[], layout: ILabelLayout, addTransform?: boolean, hideCollidedLabels?: boolean): Array<T & LabelEnabledDataPoint>;
    private calculateTransform;
    private processDataPoints;
    private shouldKeepLabel;
    /**
     * Merges the label element info with the panel element info and returns correct label info.
     * @param source The label info.
     */
    getLabelInfo(source: IDataLabelInfo): IDataLabelInfo;
    /**
    * (Private) Calculates element position using anchor point..
    */
    private calculateContentPositionFromPoint;
    /** (Private) Calculates element position using anchor rect. */
    private calculateContentPositionFromRect;
    /** (Private) Calculates element inside center position using anchor rect. */
    private handleInsideCenterPosition;
    /** (Private) Calculates element inside end position using anchor rect. */
    private handleInsideEndPosition;
    /** (Private) Calculates element inside base position using anchor rect. */
    private handleInsideBasePosition;
    /** (Private) Calculates element outside end position using anchor rect. */
    private handleOutsideEndPosition;
    /** (Private) Calculates element outside base position using anchor rect. */
    private handleOutsideBasePosition;
    /**  (Private) Calculates element position. */
    private calculateContentPosition;
    /** (Private) Check for collisions. */
    private hasCollisions;
    private createViewportIntersection;
    private checkOutsidePlacementCollisions;
    static isValid(rect: IRect): boolean;
}
